<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>KTT í†µí•© ëŒ€ì‹œë³´ë“œ (VOC + í•´ì§€íŒŒì´í”„ë¼ì¸)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- PapaParse (CSV íŒŒì„œ) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- Kakao ì§€ë„ -->
  <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=af04a0a8e5416c95eaa04cccc060031d"></script>

  <style>
    body {
      margin: 0;
      display: flex;
      background: #f5f5f7;
      font-family: "Segoe UI", "Apple SD Gothic Neo", sans-serif;
    }

    /* ì¢Œì¸¡ í•„í„° íŒ¨ë„ */
    .sidebar {
      width: 260px;
      background: #ffffff;
      padding: 20px;
      border-right: 1px solid #ddd;
      height: 100vh;
      overflow-y: auto;
    }

    .sidebar h2 {
      font-size: 18px;
      margin-bottom: 10px;
      border-bottom: 2px solid #eee;
      padding-bottom: 6px;
    }

    .content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }

    .chart-box {
      background: #fff;
      padding: 15px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      margin-bottom: 30px;
    }

    #map {
      width: 100%;
      height: 420px;
      border-radius: 12px;
    }

    button, select {
      width: 100%;
      padding: 10px;
      margin: 6px 0;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fafafa;
      font-size: 14px;
      cursor: pointer;
    }

    label {
      display: block;
      padding: 5px 0;
      font-size: 13px;
    }

    h3 {
      margin-top: 0;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>

<div class="sidebar">
  <h2>ğŸ“Œ í•„í„°</h2>

  <label>ë‹´ë‹¹ì˜ì—…ì±„ë„</label>
  <select id="channelFilter">
      <option value="ALL">ì „ì²´</option>
      <option value="SP">SP</option>
      <option value="SC">SC</option>
      <option value="AM">AM</option>
  </select>

  <label>í•´ì§€ìœ„í—˜ë„ (%)</label>
  <label><input type="radio" name="risk" value="ALL" checked> ì „ì²´</label>
  <label><input type="radio" name="risk" value="0"> 0 ~ 25%</label>
  <label><input type="radio" name="risk" value="25"> 25 ~ 50%</label>
  <label><input type="radio" name="risk" value="50"> 50 ~ 75%</label>
  <label><input type="radio" name="risk" value="75"> 75 ~ 100%</label>

  <label>í‘œì‹œ ê¸°ì¤€ (í•´ì§€íŒŒì´í”„ë¼ì¸)</label>
  <button onclick="setMode('count')">ê±´ìˆ˜</button>
  <button onclick="setMode('amount')">ê¸ˆì•¡(ì²œì›)</button>
</div>

<div class="content">

  <div class="chart-box">
      <h3>ğŸ“ VOC ì„¤ì¹˜ ì£¼ì†Œ ì§€ë„</h3>
      <div id="map"></div>
  </div>

  <div class="chart-box">
      <h3>ğŸ“Š ê´€ë¦¬ë³¸ë¶€ / ê´€ë¦¬ì§€ì‚¬ë³„ í•´ì§€ í˜„í™© (ê±´ìˆ˜ ë˜ëŠ” ê¸ˆì•¡)</h3>
      <canvas id="pipelineBranchChart"></canvas>
  </div>

  <div class="chart-box">
      <h3>ğŸ“Š ë°©ì–´ì§„í–‰ë‹¨ê³„ (ì§„í–‰ì¤‘ / ë°©ì–´ì‹¤íŒ¨ / ë°©ì–´ì„±ê³µ)</h3>
      <canvas id="pipelineStageChart"></canvas>
  </div>

  <div class="chart-box">
      <h3>ğŸ“Š VOC ê´€ë¦¬ì§€ì‚¬ë³„ ìƒíƒœ (ì ì¸µ ë§‰ëŒ€)</h3>
      <canvas id="vocBranchChart"></canvas>
  </div>

  <div class="chart-box">
      <h3>ğŸ“Š VOC ë‹´ë‹¹ìë³„ ìƒíƒœ (Top 20, ì ì¸µ ë§‰ëŒ€)</h3>
      <canvas id="vocAgentChart"></canvas>
  </div>

</div>

<script>
/* ---------------------------------------------------------
   ğŸ“Œ ë°ì´í„° ê²½ë¡œ
--------------------------------------------------------- */
const VOC_CSV_URL =
  "https://raw.githubusercontent.com/bough38-web/retention-dashboard/main/VOCì •ë³´ì¡°íšŒ_clean.csv";

const PIPELINE_CSV_URL =
  "https://raw.githubusercontent.com/bough38-web/retention-dashboard/main/í•´ì§€íŒŒì´í”„ë¼ì¸ì¡°íšŒ_clean.csv";

/* ---------------------------------------------------------
   ğŸ“Œ ì „ì—­ ìƒíƒœê°’
--------------------------------------------------------- */
let mode = "count"; // count ë˜ëŠ” amount
let vocData = [];
let pipelineData = [];

// ì°¨íŠ¸ ì¸ìŠ¤í„´ìŠ¤
let pipelineBranchChart = null;
let pipelineStageChart = null;
let vocBranchChart = null;
let vocAgentChart = null;

// ì¹´ì¹´ì˜¤ë§µ
let map;
let markers = [];

/* ---------------------------------------------------------
   ğŸ“Œ ë„ìš°ë¯¸ í•¨ìˆ˜ë“¤
--------------------------------------------------------- */

// ì§€ì‚¬ëª… ì •ê·œí™” ("ì§€ì‚¬" ì œê±°)
function normalizeBranch(name) {
  if (!name) return "";
  return String(name).replace("ì§€ì‚¬", "").trim();
}

// ê³„ì•½ë²ˆí˜¸ ì •ê·œí™” (ìˆ«ìë§Œ 8ìë¦¬)
function cleanContractNumber(raw) {
  if (!raw) return "";
  const digits = String(raw).replace(/\D/g, "");
  return digits.slice(0, 8);
}

// ê¸ˆì•¡ì„ ì²œì› ë‹¨ìœ„ë¡œ ë³€í™˜
function toThousandWon(raw) {
  if (!raw) return 0;
  const num = parseFloat(String(raw).replace(/,/g, ""));
  if (isNaN(num)) return 0;
  return Math.round(num / 1000);
}

// ìœ„í—˜ë„ êµ¬ê°„ ì²´í¬
function checkRisk(value, selected) {
  if (selected === "ALL") return true;
  const v = parseFloat(value);
  if (isNaN(v)) return false;
  const s = parseInt(selected);

  if (s === 0) return v >= 0 && v < 25;
  if (s === 25) return v >= 25 && v < 50;
  if (s === 50) return v >= 50 && v < 75;
  if (s === 75) return v >= 75 && v <= 100;
  return true;
}

// CSV ë¡œë”©
async function loadCsv(url) {
  const response = await fetch(url);
  const text = await response.text();
  return new Promise((resolve) => {
    Papa.parse(text, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => resolve(results.data),
    });
  });
}

/* ---------------------------------------------------------
   ğŸ“Œ ì¹´ì¹´ì˜¤ ì§€ë„ ê´€ë ¨
--------------------------------------------------------- */
function initMap() {
  const container = document.getElementById("map");
  map = new kakao.maps.Map(container, {
    center: new kakao.maps.LatLng(37.5665, 126.9780),
    level: 7,
  });
}

// ì§€ë„ë§í¬ì—ì„œ ìœ„ê²½ë„ ì¶”ì¶œ (êµ¬ê¸€ë§µ q=lat,lng í˜•ì‹ ê°€ì •)
function extractLatLng(url) {
  if (!url || !url.includes("q=")) return null;
  try {
    const coords = url.split("q=")[1].split(",");
    return {
      lat: parseFloat(coords[0]),
      lng: parseFloat(coords[1]),
    };
  } catch {
    return null;
  }
}

// VOC ì§€ë„ ë§ˆì»¤ í‘œì‹œ
function drawVocMarkers() {
  if (!map) return;

  // ê¸°ì¡´ ë§ˆì»¤ ì œê±°
  markers.forEach(m => m.setMap(null));
  markers = [];

  vocData.forEach(row => {
    const pos = extractLatLng(row["ì§€ë„ë§í¬"]);
    if (!pos) return;

    const marker = new kakao.maps.Marker({
      position: new kakao.maps.LatLng(pos.lat, pos.lng),
      map: map
    });

    markers.push(marker);
  });
}

/* ---------------------------------------------------------
   ğŸ“Œ í•„í„° ê°’ ê°€ì ¸ì˜¤ê¸° & ëª¨ë“œ ë³€ê²½
--------------------------------------------------------- */
function getSelectedChannel() {
  const sel = document.getElementById("channelFilter");
  return sel ? sel.value : "ALL";
}

function getSelectedRisk() {
  const radio = document.querySelector('input[name="risk"]:checked');
  return radio ? radio.value : "ALL";
}

function setMode(m) {
  mode = m;
  updatePipelineCharts();
}

/* ---------------------------------------------------------
   ğŸ“Œ í•´ì§€íŒŒì´í”„ë¼ì¸: ê´€ë¦¬ë³¸ë¶€/ì§€ì‚¬ ì§‘ê³„
--------------------------------------------------------- */
function getPipelineBranchAgg() {
  const channel = getSelectedChannel();
  const risk = getSelectedRisk();
  const agg = {};

  pipelineData.forEach(row => {
    // í•„í„° ì ìš©
    if (channel !== "ALL" && row["ë‹´ë‹¹ì˜ì—…ì±„ë„"] !== channel) return;
    if (!checkRisk(row["í•´ì§€ìœ„í—˜ë„"], risk)) return;

    const head = (row["ê´€ë¦¬ë³¸ë¶€"] || "").trim();
    const branch = normalizeBranch(row["ê´€ë¦¬ì§€ì‚¬"]);
    if (!head || !branch) return;

    const key = head + " / " + branch;

    if (!agg[key]) {
      agg[key] = { count: 0, amount: 0 };
    }

    // ê±´ìˆ˜: ê³„ì•½ë²ˆí˜¸ ê¸°ì¤€
    const cleaned = cleanContractNumber(row["ê³„ì•½ë²ˆí˜¸"]);
    if (cleaned) {
      agg[key].count += 1;
    }

    // ê¸ˆì•¡: KTTì›”ì •ë£Œ(ì¡°ì •)
    agg[key].amount += toThousandWon(row["KTTì›”ì •ë£Œ(ì¡°ì •)"]);
  });

  const entries = Object.entries(agg);
  // ì •ë ¬ì€ í˜„ì¬ ëª¨ë“œ ê¸°ì¤€ìœ¼ë¡œ
  entries.sort((a, b) => {
    const av = mode === "count" ? a[1].count : a[1].amount;
    const bv = mode === "count" ? b[1].count : b[1].amount;
    return bv - av;
  });

  const labels = entries.map(e => e[0]);
  const counts = entries.map(e => e[1].count);
  const amounts = entries.map(e => e[1].amount);

  return { labels, counts, amounts };
}

function drawPipelineBranchChart() {
  const ctx = document.getElementById("pipelineBranchChart").getContext("2d");
  const { labels, counts, amounts } = getPipelineBranchAgg();

  const dataArray = mode === "count" ? counts : amounts;
  const label = mode === "count" ? "ê±´ìˆ˜" : "ê¸ˆì•¡(ì²œì›)";

  if (pipelineBranchChart) {
    pipelineBranchChart.destroy();
  }

  pipelineBranchChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label,
        data: dataArray,
      }]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const v = ctx.parsed.y;
              if (mode === "count") return v + " ê±´";
              return v + " ì²œì›";
            }
          }
        }
      },
      scales: {
        x: {
          ticks: { autoSkip: false, maxRotation: 60, minRotation: 20 }
        },
        y: {
          beginAtZero: true
        }
      }
    }
  });
}

/* ---------------------------------------------------------
   ğŸ“Œ í•´ì§€íŒŒì´í”„ë¼ì¸: ë°©ì–´ì§„í–‰ë‹¨ê³„ ì ì¸µ ë§‰ëŒ€
--------------------------------------------------------- */
function getPipelineStageAgg() {
  const channel = getSelectedChannel();
  const risk = getSelectedRisk();

  const stages = ["ì§„í–‰ì¤‘", "ë°©ì–´ì‹¤íŒ¨", "ë°©ì–´ì„±ê³µ"];
  const agg = {};

  pipelineData.forEach(row => {
    if (channel !== "ALL" && row["ë‹´ë‹¹ì˜ì—…ì±„ë„"] !== channel) return;
    if (!checkRisk(row["í•´ì§€ìœ„í—˜ë„"], risk)) return;

    const branch = normalizeBranch(row["ê´€ë¦¬ì§€ì‚¬"]);
    if (!branch) return;
    const stage = (row["ë°©ì–´ì§„í–‰ë‹¨ê³„"] || "").trim() || "ê¸°íƒ€";
    if (!agg[branch]) {
      agg[branch] = { "ì§„í–‰ì¤‘": 0, "ë°©ì–´ì‹¤íŒ¨": 0, "ë°©ì–´ì„±ê³µ": 0 };
    }
    if (stages.includes(stage)) {
      agg[branch][stage] += 1;
    }
  });

  const labels = Object.keys(agg);
  const ì§„í–‰ì¤‘ = labels.map(b => agg[b]["ì§„í–‰ì¤‘"]);
  const ë°©ì–´ì‹¤íŒ¨ = labels.map(b => agg[b]["ë°©ì–´ì‹¤íŒ¨"]);
  const ë°©ì–´ì„±ê³µ = labels.map(b => agg[b]["ë°©ì–´ì„±ê³µ"]);

  return { labels, ì§„í–‰ì¤‘, ë°©ì–´ì‹¤íŒ¨, ë°©ì–´ì„±ê³µ };
}

function drawPipelineStageChart() {
  const ctx = document.getElementById("pipelineStageChart").getContext("2d");
  const { labels, ì§„í–‰ì¤‘, ë°©ì–´ì‹¤íŒ¨, ë°©ì–´ì„±ê³µ } = getPipelineStageAgg();

  if (pipelineStageChart) {
    pipelineStageChart.destroy();
  }

  pipelineStageChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "ì§„í–‰ì¤‘", data: ì§„í–‰ì¤‘, stack: "stage" },
        { label: "ë°©ì–´ì‹¤íŒ¨", data: ë°©ì–´ì‹¤íŒ¨, stack: "stage" },
        { label: "ë°©ì–´ì„±ê³µ", data: ë°©ì–´ì„±ê³µ, stack: "stage" },
      ]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: (ctx) => ctx.dataset.label + ": " + ctx.parsed.y + " ê±´"
          }
        }
      },
      scales: {
        x: { stacked: true },
        y: { stacked: true, beginAtZero: true }
      }
    }
  });
}

/* ---------------------------------------------------------
   ğŸ“Œ VOC: ê´€ë¦¬ì§€ì‚¬/ë‹´ë‹¹ì ìƒíƒœ ì ì¸µ ë§‰ëŒ€
--------------------------------------------------------- */
function aggregateVocBy(fieldName, limit = 20) {
  const agg = {};
  const statuses = ["ì²˜ë¦¬ì™„ë£Œ", "ì ‘ìˆ˜", "ë¯¸ì ‘ìˆ˜"];

  vocData.forEach(row => {
    let key;
    if (fieldName === "ê´€ë¦¬ì§€ì‚¬") {
      key = normalizeBranch(row["ê´€ë¦¬ì§€ì‚¬"]);
    } else {
      key = (row[fieldName] || "").trim();
    }
    if (!key) return;

    const status = (row["ìƒíƒœ"] || "").trim();
    if (!agg[key]) {
      agg[key] = { "ì²˜ë¦¬ì™„ë£Œ": 0, "ì ‘ìˆ˜": 0, "ë¯¸ì ‘ìˆ˜": 0 };
    }
    if (statuses.includes(status)) {
      agg[key][status] += 1;
    }
  });

  const entries = Object.entries(agg);
  // ì´ ê±´ìˆ˜ ê¸°ì¤€ ìƒìœ„ limit
  entries.sort((a, b) => {
    const at = a[1]["ì²˜ë¦¬ì™„ë£Œ"] + a[1]["ì ‘ìˆ˜"] + a[1]["ë¯¸ì ‘ìˆ˜"];
    const bt = b[1]["ì²˜ë¦¬ì™„ë£Œ"] + b[1]["ì ‘ìˆ˜"] + b[1]["ë¯¸ì ‘ìˆ˜"];
    return bt - at;
  });

  const sliced = entries.slice(0, limit);

  const labels = sliced.map(e => e[0]);
  const ì²˜ë¦¬ì™„ë£Œ = sliced.map(e => e[1]["ì²˜ë¦¬ì™„ë£Œ"]);
  const ì ‘ìˆ˜ = sliced.map(e => e[1]["ì ‘ìˆ˜"]);
  const ë¯¸ì ‘ìˆ˜ = sliced.map(e => e[1]["ë¯¸ì ‘ìˆ˜"]);

  return { labels, ì²˜ë¦¬ì™„ë£Œ, ì ‘ìˆ˜, ë¯¸ì ‘ìˆ˜ };
}

function drawVocBranchChart() {
  const ctx = document.getElementById("vocBranchChart").getContext("2d");
  const { labels, ì²˜ë¦¬ì™„ë£Œ, ì ‘ìˆ˜, ë¯¸ì ‘ìˆ˜ } = aggregateVocBy("ê´€ë¦¬ì§€ì‚¬", 30);

  if (vocBranchChart) {
    vocBranchChart.destroy();
  }

  vocBranchChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "ì²˜ë¦¬ì™„ë£Œ", data: ì²˜ë¦¬ì™„ë£Œ, stack: "voc" },
        { label: "ì ‘ìˆ˜", data: ì ‘ìˆ˜, stack: "voc" },
        { label: "ë¯¸ì ‘ìˆ˜", data: ë¯¸ì ‘ìˆ˜, stack: "voc" },
      ]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: (ctx) => ctx.dataset.label + ": " + ctx.parsed.y + " ê±´"
          }
        }
      },
      scales: {
        x: { stacked: true },
        y: { stacked: true, beginAtZero: true }
      }
    }
  });
}

function drawVocAgentChart() {
  const ctx = document.getElementById("vocAgentChart").getContext("2d");
  const { labels, ì²˜ë¦¬ì™„ë£Œ, ì ‘ìˆ˜, ë¯¸ì ‘ìˆ˜ } = aggregateVocBy("ë‹´ë‹¹ì", 20);

  if (vocAgentChart) {
    vocAgentChart.destroy();
  }

  vocAgentChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "ì²˜ë¦¬ì™„ë£Œ", data: ì²˜ë¦¬ì™„ë£Œ, stack: "voc-agent" },
        { label: "ì ‘ìˆ˜", data: ì ‘ìˆ˜, stack: "voc-agent" },
        { label: "ë¯¸ì ‘ìˆ˜", data: ë¯¸ì ‘ìˆ˜, stack: "voc-agent" },
      ]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: (ctx) => ctx.dataset.label + ": " + ctx.parsed.y + " ê±´"
          }
        }
      },
      scales: {
        x: { stacked: true },
        y: { stacked: true, beginAtZero: true }
      }
    }
  });
}

/* ---------------------------------------------------------
   ğŸ“Œ ì°¨íŠ¸ ì „ì²´ ì—…ë°ì´íŠ¸
--------------------------------------------------------- */
function updatePipelineCharts() {
  drawPipelineBranchChart();
  drawPipelineStageChart();
}

/* ---------------------------------------------------------
   ğŸ“Œ ì´ˆê¸°í™”
--------------------------------------------------------- */
async function initDashboard() {
  // ì§€ë„ ë¨¼ì € ì´ˆê¸°í™”
  initMap();

  // CSV ë°ì´í„° ë¡œë“œ
  vocData = await loadCsv(VOC_CSV_URL);
  pipelineData = await loadCsv(PIPELINE_CSV_URL);

  // VOC ì§€ë„ ë§ˆì»¤
  drawVocMarkers();

  // ì°¨íŠ¸ë“¤ ë Œë”ë§
  drawPipelineBranchChart();
  drawPipelineStageChart();
  drawVocBranchChart();
  drawVocAgentChart();

  // í•„í„° ë³€ê²½ ì´ë²¤íŠ¸
  const channelSel = document.getElementById("channelFilter");
  if (channelSel) {
    channelSel.addEventListener("change", updatePipelineCharts);
  }
  const riskRadios = document.querySelectorAll('input[name="risk"]');
  riskRadios.forEach(r => {
    r.addEventListener("change", updatePipelineCharts);
  });
}

// í˜ì´ì§€ ë¡œë“œ ì‹œ ì‹¤í–‰
window.addEventListener("load", initDashboard);
</script>

</body>
</html>
