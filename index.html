<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>KTT í†µí•© ëŒ€ì‹œë³´ë“œ (VOC + í•´ì§€íŒŒì´í”„ë¼ì¸)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- PapaParse (CSV íŒŒì„œ) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- Kakao ì§€ë„ (https ëª…ì‹œ) -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=af04a0a8e5416c95eaa04cccc060031d"></script>

  <style>
    body {
      margin: 0;
      display: flex;
      background: #f5f5f7;
      font-family: "Apple SD Gothic Neo", "Segoe UI", sans-serif;
    }

    .sidebar {
      width: 260px;
      background: #ffffff;
      padding: 20px;
      border-right: 1px solid #ddd;
      height: 100vh;
      overflow-y: auto;
    }

    .sidebar h2 {
      font-size: 18px;
      margin-bottom: 10px;
      border-bottom: 2px solid #eee;
      padding-bottom: 6px;
    }

    .content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }

    .chart-box {
      background: #fff;
      padding: 15px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      margin-bottom: 30px;
    }

    #map {
      width: 100%;
      height: 420px;
      border-radius: 12px;
    }

    button, select {
      width: 100%;
      padding: 10px;
      margin: 6px 0;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fafafa;
      font-size: 14px;
      cursor: pointer;
    }

    label {
      display: block;
      padding: 5px 0;
      font-size: 13px;
    }

    h3 {
      margin-top: 0;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>

<!-- ì¢Œì¸¡ í•„í„° íŒ¨ë„ -->
<div class="sidebar">
  <h2>ğŸ“Œ í•„í„°</h2>

  <label>ë‹´ë‹¹ì˜ì—…ì±„ë„</label>
  <select id="channelFilter">
      <option value="ALL">ì „ì²´</option>
      <option value="SP">SP</option>
      <option value="SC">SC</option>
      <option value="AM">AM</option>
  </select>

  <label>í•´ì§€ìœ„í—˜ë„ (%)</label>
  <label><input type="radio" name="risk" value="ALL" checked> ì „ì²´</label>
  <label><input type="radio" name="risk" value="0"> 0 ~ 25%</label>
  <label><input type="radio" name="risk" value="25"> 25 ~ 50%</label>
  <label><input type="radio" name="risk" value="50"> 50 ~ 75%</label>
  <label><input type="radio" name="risk" value="75"> 75 ~ 100%</label>

  <label>í‘œì‹œ ê¸°ì¤€ (í•´ì§€íŒŒì´í”„ë¼ì¸)</label>
  <button onclick="setMode('count')">ê±´ìˆ˜</button>
  <button onclick="setMode('amount')">ê¸ˆì•¡(ì²œì›)</button>
</div>

<!-- ìš°ì¸¡ ëŒ€ì‹œë³´ë“œ ì˜ì—­ -->
<div class="content">

  <div class="chart-box">
      <h3>ğŸ“ VOC ì„¤ì¹˜ ì£¼ì†Œ ì§€ë„</h3>
      <div id="map"></div>
  </div>

  <div class="chart-box">
      <h3>ğŸ“Š ê´€ë¦¬ë³¸ë¶€ / ê´€ë¦¬ì§€ì‚¬ë³„ í•´ì§€ í˜„í™© (ê±´ìˆ˜ ë˜ëŠ” ê¸ˆì•¡)</h3>
      <canvas id="pipelineBranchChart"></canvas>
  </div>

  <div class="chart-box">
      <h3>ğŸ“Š ë°©ì–´ì§„í–‰ë‹¨ê³„ (ì§„í–‰ì¤‘ / ë°©ì–´ì‹¤íŒ¨ / ë°©ì–´ì„±ê³µ)</h3>
      <canvas id="pipelineStageChart"></canvas>
  </div>

  <div class="chart-box">
      <h3>ğŸ“Š VOC ê´€ë¦¬ì§€ì‚¬ë³„ ìƒíƒœ (ì ì¸µ ë§‰ëŒ€)</h3>
      <canvas id="vocBranchChart"></canvas>
  </div>

  <div class="chart-box">
      <h3>ğŸ“Š VOC ë‹´ë‹¹ìë³„ ìƒíƒœ (Top 20, ì ì¸µ ë§‰ëŒ€)</h3>
      <canvas id="vocAgentChart"></canvas>
  </div>

</div>

<script>
/* ---------------------------------------------------------
   ğŸ“Œ CSV ê²½ë¡œ (ì˜ë¬¸ íŒŒì¼)
--------------------------------------------------------- */
const VOC_CSV_URL =
  "https://raw.githubusercontent.com/bough38-web/retention-dashboard/main/voc.csv";

const PIPELINE_CSV_URL =
  "https://raw.githubusercontent.com/bough38-web/retention-dashboard/main/pipeline.csv";

/* ---------------------------------------------------------
   ğŸ“Œ ì „ì—­ ìƒíƒœê°’
--------------------------------------------------------- */
let mode = "count";
let vocData = [];
let pipelineData = [];

let pipelineBranchChart = null;
let pipelineStageChart = null;
let vocBranchChart = null;
let vocAgentChart = null;

// ì¹´ì¹´ì˜¤ë§µ ê°ì²´
let map = null;
let markers = [];

/* ---------------------------------------------------------
   ğŸ“Œ ê³µí†µ ìœ í‹¸
--------------------------------------------------------- */
function normalizeBranch(name) {
  if (!name) return "";
  return String(name).replace("ì§€ì‚¬", "").trim();
}

function cleanContractNumber(raw) {
  if (!raw) return "";
  const digits = String(raw).replace(/\D/g, "");
  return digits.slice(0, 8);
}

function toThousandWon(raw) {
  if (!raw) return 0;
  const num = parseFloat(String(raw).replace(/,/g, ""));
  if (isNaN(num)) return 0;
  return Math.round(num / 1000);
}

function checkRisk(value, selected) {
  if (selected === "ALL") return true;
  const v = parseFloat(value);
  if (isNaN(v)) return false;
  const s = parseInt(selected);

  if (s === 0) return v >= 0 && v < 25;
  if (s === 25) return v >= 25 && v < 50;
  if (s === 50) return v >= 50 && v < 75;
  if (s === 75) return v >= 75 && v <= 100;
  return true;
}

async function loadCsv(url) {
  const response = await fetch(url);
  const text = await response.text();
  return new Promise((resolve) => {
    Papa.parse(text, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => resolve(results.data),
    });
  });
}

/* ---------------------------------------------------------
   ğŸ“Œ Kakao ì§€ë„ (ì—ëŸ¬ ë°©ì–´ ë²„ì „)
--------------------------------------------------------- */
function initMapSafe() {
  // kakao SDKê°€ ì•ˆ ë–  ìˆì–´ë„ ì—ëŸ¬ ì•ˆ ë‚´ê³  ê·¸ëƒ¥ íŒ¨ìŠ¤
  if (!window.kakao || !window.kakao.maps) {
    console.warn("Kakao ì§€ë„ SDKë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì§€ë„ëŠ” ë¹„í‘œì‹œ, ì°¨íŠ¸ë§Œ ë™ì‘í•©ë‹ˆë‹¤.");
    map = null;
    return;
  }

  const container = document.getElementById("map");
  map = new window.kakao.maps.Map(container, {
    center: new window.kakao.maps.LatLng(37.5665, 126.9780),
    level: 7,
  });
}

// ì§€ë„ë§í¬ì—ì„œ ìœ„ê²½ë„ ì¶”ì¶œ (êµ¬ê¸€ë§µ q=lat,lng í˜•ì‹ ê°€ì •)
function extractLatLng(url) {
  if (!url || !url.includes("q=")) return null;
  try {
    const coords = url.split("q=")[1].split(",");
    return {
      lat: parseFloat(coords[0]),
      lng: parseFloat(coords[1]),
    };
  } catch {
    return null;
  }
}

function drawVocMarkers() {
  if (!map || !window.kakao || !window.kakao.maps) return;

  // ê¸°ì¡´ ë§ˆì»¤ ì œê±°
  markers.forEach(m => m.setMap(null));
  markers = [];

  vocData.forEach(row => {
    const pos = extractLatLng(row["ì§€ë„ë§í¬"]);
    if (!pos) return;

    const marker = new window.kakao.maps.Marker({
      position: new window.kakao.maps.LatLng(pos.lat, pos.lng),
      map: map
    });

    markers.push(marker);
  });
}

/* ---------------------------------------------------------
   ğŸ“Œ í•„í„° & ëª¨ë“œ
--------------------------------------------------------- */
function getSelectedChannel() {
  const sel = document.getElementById("channelFilter");
  return sel ? sel.value : "ALL";
}

function getSelectedRisk() {
  const radio = document.querySelector('input[name="risk"]:checked');
  return radio ? radio.value : "ALL";
}

function setMode(m) {
  mode = m;
  updatePipelineCharts();
}

/* ---------------------------------------------------------
   ğŸ“Œ í•´ì§€íŒŒì´í”„ë¼ì¸ ì§‘ê³„
--------------------------------------------------------- */
function getPipelineBranchAgg() {
  const channel = getSelectedChannel();
  const risk = getSelectedRisk();
  const agg = {};

  pipelineData.forEach(row => {
    if (channel !== "ALL" && row["ë‹´ë‹¹ì˜ì—…ì±„ë„"] !== channel) return;
    if (!checkRisk(row["í•´ì§€ìœ„í—˜ë„"], risk)) return;

    const head = (row["ê´€ë¦¬ë³¸ë¶€"] || "").trim();
    const branch = normalizeBranch(row["ê´€ë¦¬ì§€ì‚¬"]);
    if (!head || !branch) return;

    const key = head + " / " + branch;

    if (!agg[key]) {
      agg[key] = { count: 0, amount: 0 };
    }

    const cleaned = cleanContractNumber(row["ê³„ì•½ë²ˆí˜¸"]);
    if (cleaned) {
      agg[key].count += 1;
    }

    agg[key].amount += toThousandWon(row["KTTì›”ì •ë£Œ(ì¡°ì •)"]);
  });

  const entries = Object.entries(agg);
  entries.sort((a, b) => {
    const av = mode === "count" ? a[1].count : a[1].amount;
    const bv = mode === "count" ? b[1].count : b[1].amount;
    return bv - av;
  });

  const labels = entries.map(e => e[0]);
  const counts = entries.map(e => e[1].count);
  const amounts = entries.map(e => e[1].amount);

  return { labels, counts, amounts };
}

function drawPipelineBranchChart() {
  const ctx = document.getElementById("pipelineBranchChart").getContext("2d");
  const { labels, counts, amounts } = getPipelineBranchAgg();

  const dataArray = mode === "count" ? counts : amounts;
  const label = mode === "count" ? "ê±´ìˆ˜" : "ê¸ˆì•¡(ì²œì›)";

  if (pipelineBranchChart) pipelineBranchChart.destroy();

  pipelineBranchChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label,
        data: dataArray,
      }]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const v = ctx.parsed.y;
              return mode === "count" ? `${v} ê±´` : `${v} ì²œì›`;
            }
          }
        }
      },
      scales: {
        x: {
          ticks: { autoSkip: false, maxRotation: 60, minRotation: 20 }
        },
        y: {
          beginAtZero: true
        }
      }
    }
  });
}

/* ---------------------------------------------------------
   ğŸ“Œ í•´ì§€íŒŒì´í”„ë¼ì¸: ë°©ì–´ì§„í–‰ë‹¨ê³„ ì ì¸µ
--------------------------------------------------------- */
function getPipelineStageAgg() {
  const channel = getSelectedChannel();
  const risk = getSelectedRisk();
  const stages = ["ì§„í–‰ì¤‘", "ë°©ì–´ì‹¤íŒ¨", "ë°©ì–´ì„±ê³µ"];
  const agg = {};

  pipelineData.forEach(row => {
    if (channel !== "ALL" && row["ë‹´ë‹¹ì˜ì—…ì±„ë„"] !== channel) return;
    if (!checkRisk(row["í•´ì§€ìœ„í—˜ë„"], risk)) return;

    const branch = normalizeBranch(row["ê´€ë¦¬ì§€ì‚¬"]);
    if (!branch) return;
    const stage = (row["ë°©ì–´ì§„í–‰ë‹¨ê³„"] || "").trim();

    if (!agg[branch]) {
      agg[branch] = { "ì§„í–‰ì¤‘": 0, "ë°©ì–´ì‹¤íŒ¨": 0, "ë°©ì–´ì„±ê³µ": 0 };
    }
    if (stages.includes(stage)) {
      agg[branch][stage] += 1;
    }
  });

  const labels = Object.keys(agg);
  const ì§„í–‰ì¤‘ = labels.map(b => agg[b]["ì§„í–‰ì¤‘"]);
  const ë°©ì–´ì‹¤íŒ¨ = labels.map(b => agg[b]["ë°©ì–´ì‹¤íŒ¨"]);
  const ë°©ì–´ì„±ê³µ = labels.map(b => agg[b]["ë°©ì–´ì„±ê³µ"]);

  return { labels, ì§„í–‰ì¤‘, ë°©ì–´ì‹¤íŒ¨, ë°©ì–´ì„±ê³µ };
}

function drawPipelineStageChart() {
  const ctx = document.getElementById("pipelineStageChart").getContext("2d");
  const { labels, ì§„í–‰ì¤‘, ë°©ì–´ì‹¤íŒ¨, ë°©ì–´ì„±ê³µ } = getPipelineStageAgg();

  if (pipelineStageChart) pipelineStageChart.destroy();

  pipelineStageChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "ì§„í–‰ì¤‘", data: ì§„í–‰ì¤‘, stack: "stage" },
        { label: "ë°©ì–´ì‹¤íŒ¨", data: ë°©ì–´ì‹¤íŒ¨, stack: "stage" },
        { label: "ë°©ì–´ì„±ê³µ", data: ë°©ì–´ì„±ê³µ, stack: "stage" },
      ]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y} ê±´`
          }
        }
      },
      scales: {
        x: { stacked: true },
        y: { stacked: true, beginAtZero: true }
      }
    }
  });
}

/* ---------------------------------------------------------
   ğŸ“Œ VOC: ê´€ë¦¬ì§€ì‚¬ / ë‹´ë‹¹ì ì ì¸µ
--------------------------------------------------------- */
function aggregateVocBy(fieldName, limit = 20) {
  const agg = {};
  const statuses = ["ì²˜ë¦¬ì™„ë£Œ", "ì ‘ìˆ˜", "ë¯¸ì ‘ìˆ˜"];

  vocData.forEach(row => {
    let key;
    if (fieldName === "ê´€ë¦¬ì§€ì‚¬") {
      key = normalizeBranch(row["ê´€ë¦¬ì§€ì‚¬"]);
    } else {
      key = (row[fieldName] || "").trim();
    }
    if (!key) return;

    const status = (row["ìƒíƒœ"] || "").trim();
    if (!agg[key]) {
      agg[key] = { "ì²˜ë¦¬ì™„ë£Œ": 0, "ì ‘ìˆ˜": 0, "ë¯¸ì ‘ìˆ˜": 0 };
    }
    if (statuses.includes(status)) {
      agg[key][status] += 1;
    }
  });

  const entries = Object.entries(agg);
  entries.sort((a, b) => {
    const at = a[1]["ì²˜ë¦¬ì™„ë£Œ"] + a[1]["ì ‘ìˆ˜"] + a[1]["ë¯¸ì ‘ìˆ˜"];
    const bt = b[1]["ì²˜ë¦¬ì™„ë£Œ"] + b[1]["ì ‘ìˆ˜"] + b[1]["ë¯¸ì ‘ìˆ˜"];
    return bt - at;
  });

  const sliced = entries.slice(0, limit);

  const labels = sliced.map(e => e[0]);
  const ì²˜ë¦¬ì™„ë£Œ = sliced.map(e => e[1]["ì²˜ë¦¬ì™„ë£Œ"]);
  const ì ‘ìˆ˜ = sliced.map(e => e[1]["ì ‘ìˆ˜"]);
  const ë¯¸ì ‘ìˆ˜ = sliced.map(e => e[1]["ë¯¸ì ‘ìˆ˜"]);

  return { labels, ì²˜ë¦¬ì™„ë£Œ, ì ‘ìˆ˜, ë¯¸ì ‘ìˆ˜ };
}

function drawVocBranchChart() {
  const ctx = document.getElementById("vocBranchChart").getContext("2d");
  const { labels, ì²˜ë¦¬ì™„ë£Œ, ì ‘ìˆ˜, ë¯¸ì ‘ìˆ˜ } = aggregateVocBy("ê´€ë¦¬ì§€ì‚¬", 30);

  if (vocBranchChart) vocBranchChart.destroy();

  vocBranchChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "ì²˜ë¦¬ì™„ë£Œ", data: ì²˜ë¦¬ì™„ë£Œ, stack: "voc" },
        { label: "ì ‘ìˆ˜", data: ì ‘ìˆ˜, stack: "voc" },
        { label: "ë¯¸ì ‘ìˆ˜", data: ë¯¸ì ‘ìˆ˜, stack: "voc" },
      ]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y} ê±´`
          }
        }
      },
      scales: {
        x: { stacked: true },
        y: { stacked: true, beginAtZero: true }
      }
    }
  });
}

function drawVocAgentChart() {
  const ctx = document.getElementById("vocAgentChart").getContext("2d");
  const { labels, ì²˜ë¦¬ì™„ë£Œ, ì ‘ìˆ˜, ë¯¸ì ‘ìˆ˜ } = aggregateVocBy("ë‹´ë‹¹ì", 20);

  if (vocAgentChart) vocAgentChart.destroy();

  vocAgentChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "ì²˜ë¦¬ì™„ë£Œ", data: ì²˜ë¦¬ì™„ë£Œ, stack: "voc-agent" },
        { label: "ì ‘ìˆ˜", data: ì ‘ìˆ˜, stack: "voc-agent" },
        { label: "ë¯¸ì ‘ìˆ˜", data: ë¯¸ì ‘ìˆ˜, stack: "voc-agent" },
      ]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y} ê±´`
          }
        }
      },
      scales: {
        x: { stacked: true },
        y: { stacked: true, beginAtZero: true }
      }
    }
  });
}

/* ---------------------------------------------------------
   ğŸ“Œ ì°¨íŠ¸ ì „ì²´ ì—…ë°ì´íŠ¸
--------------------------------------------------------- */
function updatePipelineCharts() {
  drawPipelineBranchChart();
  drawPipelineStageChart();
}

/* ---------------------------------------------------------
   ğŸ“Œ ì´ˆê¸°í™”
--------------------------------------------------------- */
async function initDashboard() {
  // ì§€ë„ (SDK ì‹¤íŒ¨í•´ë„ ì—ëŸ¬ ì•ˆ ë‚˜ê²Œ)
  initMapSafe();

  // CSV ë°ì´í„° ë¡œë“œ
  vocData = await loadCsv(VOC_CSV_URL);
  pipelineData = await loadCsv(PIPELINE_CSV_URL);

  // ì§€ë„ ë§ˆì»¤
  drawVocMarkers();

  // ì°¨íŠ¸ ë Œë”ë§
  drawPipelineBranchChart();
  drawPipelineStageChart();
  drawVocBranchChart();
  drawVocAgentChart();

  // í•„í„° ì´ë²¤íŠ¸
  const channelSel = document.getElementById("channelFilter");
  if (channelSel) channelSel.addEventListener("change", updatePipelineCharts);

  document.querySelectorAll('input[name="risk"]').forEach(r => {
    r.addEventListener("change", updatePipelineCharts);
  });
}

window.addEventListener("load", initDashboard);
</script>

</body>
</html>
